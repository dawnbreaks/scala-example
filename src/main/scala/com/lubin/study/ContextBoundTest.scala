
package com.lubin.study

object ContextBoundTest extends App {
  
  case class Address(no: Int, street: String, city: String, state: String, zip: String)
  
  trait LabelMaker[T] {
    def makeStringLabel(value: T): String
    def makeIntLabel(value: T): Int
  }
  
  //implicit object could be used to construct context bound function
  implicit object AddesrsLabelMaker extends LabelMaker[Address] {
    override def makeStringLabel(a: Address) = "Generated by AddesrsLabelMaker|%d %s, %s, %s - %s".format(a.no, a.street, a.city, a.state, a.zip)
    override def makeIntLabel(a: Address) = a.no
  }
  
  //context bound function, implicit conversion T to Int
  implicit def address2Int[T: LabelMaker](t: T): Int = implicitly[LabelMaker[T]].makeIntLabel(t)
//  implicit def labelMaker2Int(t: Address): Int = AddesrsLabelMaker.makeIntLabel(t)
  
  
  def printInt(i: Int) = println(i)
  def printStringLabel[T : LabelMaker](t: T) = println(implicitly[LabelMaker[T]].makeStringLabel(t))
  def printIntLabel1[T : LabelMaker](t: T) = printInt(t)
  def printIntLabel2[T <% Int](t: T) = printInt(t)
  
  val address = Address(100, "Monroe Street", "Denver", "CO", "80231")
  
  //context bound
  printStringLabel(address)
  //context bound and implicit conversion
  printIntLabel1(address)
  //view bound
  printIntLabel2(address)
}



